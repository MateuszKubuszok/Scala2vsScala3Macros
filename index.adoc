// 45 minutes
:revealjs_totalTime: 2700

= Scala 2 vs Scala 3 macros

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 8+ years
* breaking things for money for 10 years
* breaking things for fun for 18(?) years
* a little bit of open source - including co-authoring Chimney for 6 years now
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
Every presentation should start with some excuse, why you even are here
--

== Agenda

[%step]
* I will focus on examples that I saw while maintaining my libraries
* what is macro method
* expressions and types
* quotes and quasiquotes
* compile time reflections
* TODO
* we don't focus on macro annotations

[NOTE.speaker]
--
TODO
--

== What is macro method?

We can intuitively think that macro method is a code generator pretending to be some object's method.

[NOTE.speaker]
--
We'll explain what we mean by that in the next few examples. We'll show how macros differ in behavior from normal method.
--

=== Let's see an example of a very simple macro

[%step]
1. Calling the impl method is the only thing we are allowed to do.
2. ``Expr[A]`` is the AST of code that represents the value of type ``A``.
3. Why Scala 2 call it blackbox will be explained later.
4. We can already notice one difference: Scala 3 has "global" expressions while Scala 2 use path-dependent types for them.

[NOTE.speaker]
--
We're start with the simplest code that returns a constant value (``01_simple_macro``).
--

=== Can the AST generation be in a different place than macro method?

[%step]
1. Impl doesn't have to be in the same definition as unquoting - it doesn't even have to be in the same package!
2. Impl has to be defined in a preceeding compilation unit to call site (macro referring to it can be in the same as call site).

[NOTE.speaker]
--
Then we're going to look at the example above but with classes (``02_macro_with_classes``).

This is the first trope that we shouldn't treat macros as methods - they don't even have to be define in the same place as what unquotes them.
--

=== Let's call some method in the macro

[NOTE.speaker]
--
Now let's call some method in the same object as the macro (``03_calling_methods``).

We are ancouraged to use full qualified name in Scala 2 as it doesn't understand context in quasiquotes.

If we used private method, compilation would fail since external code cannot access private methods (``04_calling_private``).

This is a first
--

=== Let's try printing some parameters

[%step]
[cols="1,1",%autowidth]
|===
| Scala 2
| Scala 3

| ``(c: scala.reflect.macros.blackbox.Context)``
| ``(using quotes: scala.quoted.Quotes)``

| ``c.WeakTypeTag[A]`` (or ``c.TypeTag[A]``)
| ``scala.quoted.Type[A]``

| ``c.Type``
| ``quotes.reflect.TypeRepr``

| ``c.Expr[A]``
| ``scala.quoted.Expr[A]``

| ``c.universe.Tree``
| ``quotes.reflect.Tree``

| ``c.prefix``
| no counterpart

|===

=== !

TODO: typed to untyped and back again

[cols="1,1",%autowidth]
|===
| Scala 2
| Scala 3

| ``(c: scala.reflect.macros.blackbox.Context)``
| ``(using quotes: scala.quoted.Quotes)``

| ``c.WeakTypeTag[A]`` (or ``c.TypeTag[A]``)
| ``scala.quoted.Type[A]``

| ``c.Type``
| ``quotes.reflect.TypeRepr``

| ``c.Expr[A]``
| ``scala.quoted.Expr[A]``

| ``c.universe.Tree``
| ``quotes.reflect.Tree``

| ``c.prefix``
| no counterpart

|===


=== !

[cols="1,1",%autowidth]
|===
| Scala 2
| Scala 3

| ``show(expr)`` or ``showCode(expr)``
| ``expr.asTerm.show`` or ``expr.asTerm.show(using Printer.TreeCode)``

| no counterpart
| ``expr.asTerm.show(using Printer.TreeAnsiCode)``

| ``showRaw(expr)``
| ``expr.asTerm.show(using Printer.TreeStrucrture)``

| ``weakTypeOf[A].toString``
| ``TypeRepr.of[A].show`` or ``TypeRepr.of[A].show(using Printer.TypeReprCode)``

| no counterpart
| ``TypeRepr.of[A].show(using Printer.TypeReprAnsiCode)``

| ``showRaw(weakTypeOf[A])``
| ``TypeRepr.of[A].show(using Printer.TypeReprStructure)``

|===

[NOTE.speaker]
--
At first let's print some parameters to see how printing works (``05_print_param``).

Then let's try to print ``this`` (``06_print_this``).

Scala 2 always carries around what was "before" dot macro method name, Scala 3 requires explicit passing of this.

Scala 2 require path-dependent type for WeakTypeTag as well, Scala 3 does not require it (like with Expr).

Scala 2 require the same names and positions of parametrs in macro and in called impl definition.

Scala 2 contains a special value for what was before macro, and Scala 3 requires us to pass it explicitly.
--

== TODO

[%step]
* Scala 2 types vs Scala 3 types - WeakTypeTag (no higher kinded types) vs Type (<: AnyKind)
* show that code can be checked by linters/for encapsulation
* mention difference between "typed" Types and AST representation (converting to and from)
* explain reporting - println vs blessed options
* nice table with show/showCode/showRaw vs .show(using Printer....)
* analyzing the type (primary constructor, methods etc)
* Symbols
* some nice graphs illustrating relationships with Symbols (e.g. type parameters, value parameters, returned value)
* Scala 2 vs Scala 3 - parameters lists (2 in Scala 2, one in Scala 3)
* companion objects and default values (nice example with messed up Scala 2 companion, difference in naming)
* children vs knownDirectSubtypes
* generics (typeSignature, typeSignatureIn vs ...)
* Scala 2 quasiquotes for... things vs... virtually nothing (type matches and that's it)
* implicit summoning
* macro bundles vs ... nothing really
* whitebox macros vs transparent inline def (Scala 2.12 requores Tree)

== Questions?

== Thank You!
