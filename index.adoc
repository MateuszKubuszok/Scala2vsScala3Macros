// 45 minutes
:revealjs_totalTime: 2700

= Scala 2 vs Scala 3 macros

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 8+ years
* breaking things for money for 10 years
* breaking things for fun for 18(?) years
* a little bit of open source - including co-authoring Chimney for 6 years now
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
Every presentation should start with some excuse, why you even are here
--

== Agenda

[%step]
* I will focus on examples that I saw while maintaining my libraries
* what is macro method
* expressions and types
* quotes and quasiquotes
* compile time reflections
* TODO
* we don't focus on macro annotations

[NOTE.speaker]
--
TODO
--

== Codegen pretending to be a method

=== !

[%step]
[source, scala]
--
import scala.reflect.macros.blackbox

object Scala2Example {

  def macroMethod: String =
    macro Scala2Example.macroMethodImpl

  def macroMethodImpl(c: blackbox.Context): c.Expr[String] =
    c.Expr(q""" "some constant string" """)
}
--

[%step]
[source, scala]
--
import scala.quoted.{Quotes, Expr}

object Scala3Example {

  inline def macroMethod: String =
    ${ Scala3Example.macroMethodImpl }

  def macroMethodImpl(using Quotes): Expr[String] =
    '{ "some constant string" }
}
--

[NOTE.speaker]
--
The simplest kind of code, no value parameters, no type parameters, whole result can be constructed as a single (quasi)quote.

Calling the impl method is the only thing we are allowed to do.

Expr[A] is the AST of code that represents the value of type A.

Impl has to be defined in a preceeding compilation unit to call site (macro referring to it can be in the same as call site).

Why Scala 2 call it blackbox will be explained later.

We can already notice one difference: Scala 3 has "global" expressions while Scala 2 use path-dependent types for them.
--

=== !

[%step]
[source, scala]
--
import scala.reflect.macros.blackbox

object Scala2Example {
  private def normalPrivateMethod: String = "result"
  def normalPublicMethod: String = normalPrivateMethod

  def macroMethod: String =
    macro Scala2Example.macroMethodImpl

  def macroMethodImpl(c: blackbox.Context): c.Expr[String] =
    c.Expr(q""" _root_.Scala2Example.normalPublicMethod """)
}
--

[%step]
[source, scala]
--
import scala.quoted.{Quotes, Expr}

object Scala3Example {
  private def normalPrivateMethod: String = "result"
  def normalPublicMethod: String = normalPrivateMethod

  inline def macroMethod: String =
    ${ Scala3Example.macroMethodImpl }

  def macroMethodImpl(using Quotes): Expr[String] =
    '{ normalPublicMethod }
}
--

[NOTE.speaker]
--
We are ancouraged to use full qualified name in Scala 2 as it doesn't understand context in quasiquotes.

If we used private method, compilation would fail since external code cannot access private methods.
--

=== !

[%step]
[source, scala]
--
object Scala2Example {
  def macroMethod: String = macro macroMethodImpl

  def macroMethodImpl(c: blackbox.Context): c.Expr[String] = {
    val output = s"""${show(c.prefix.tree)}
                    |${showCode(c.prefix.tree)}
                    |${showRaw(c.prefix.tree)}
                    |""".stripMargins
    c.Expr(q"$output")
  }
}
--

[%step]
[source, scala]
--
object Scala3Example {
  inline def macroMethod: String =
    ${ Scala3Example.macroMethodImpl('{ this }) }

  def macroMethodImpl(thisExpr: Expr[Scala3Example.type])(
    using Quotes
  ): Expr[String] = Expr(
    s"""${thisExpr.asTerm.show(using Printer.TreeCode)}
       |${thisExpr.asTerm.show(using Printer.TreeAnsiCode)}
       |${thisExpr.asTerm.show(using Printer.TreeStructure)}
       |""".stripMargins)
}
--

[NOTE.speaker]
--
--

=== !

[%step]
[source, scala]
--
object Scala2Example {
  def macroMethod[A](value: A): String =
    macro Scala2Example.macroMethodImpl[A]
  def macroMethodImpl[A: c.WeakTypeTag](
    c: blackbox.Context
  )(value: c.Expr[A]): c.Expr[String] = {
    val output = s"""${show(c.prefix.tree)}
                    |${showCode(c.prefix.tree)}
                    |${showRaw(c.prefix.tree)}
                    |""".stripMargins
    c.Expr(q"$output")
  }
}
--

[%step]
[source, scala]
--
object Scala3Example {
  inline def macroMethod[A](value: A): String =
    ${ Scala3Example.macroMethodImpl[A]('{ value }) }
  def macroMethodImpl[A: scala.quoted.Type](
    value: Expr[A]
  )(using Quotes): Expr[String] = Expr(
    s"""${value.asTerm.show(using Printer.TreeCode)}
       |${value.asTerm.show(using Printer.TreeAnsiCode)}
       |${value.asTerm.show(using Printer.TreeStructure)}
       |""".stripMargins)
}
--

[NOTE.speaker]
--
Scala 2 require path-dependent type for WeakTypeTag as well, Scala 3 does not require it (like with Expr).

Scala 2 require the same names and positions of parametrs in macro and in called impl definition.

Scala 2 contains a special value for what was before macro, and Scala 3 requires us to pass it explicitly.
--

== TODO

[%step]
* print types
* Scala 2 types vs Scala 3 types - WeakTypeTag (no higher kinded types) vs Type (<: AnyKind)
* create a separate repo with examples
* show that code can be checked by linters/for encapsulation
* implement printing type and value (printing type, printing expr, printing AST)
* mention difference between "typed" Types and AST representation (converting to and from)
* explain reporting - println vs blessed options
* nice table with show/showCode/showRaw vs .show(using Printer....)
* analyzing the type (primary constructor, methods etc)
* Symbols
* some nice graphs illustrating relationships with Symbols (e.g. type parameters, value parameters, returned value)
* Scala 2 vs Scala 3 - parameters lists (2 in Scala 2, one in Scala 3)
* companion objects and default values (nice example with messed up Scala 2 companion, difference in naming)
* children vs knownDirectSubtypes
* generics (typeSignature, typeSignatureIn vs ...)
* Scala 2 quasiquotes for... things vs... virtually nothing (type matches and that's it)
* implicit summoning
* macro bundles vs ... nothing really
* whitebox macros vs transparent inline def (Scala 2.12 requores Tree)

== Questions?

== Thank You!
