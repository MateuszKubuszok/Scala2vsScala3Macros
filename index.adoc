// 45 minutes
:revealjs_totalTime: 2700

= Scala 2 vs Scala 3 macros

Mateusz Kubuszok

== About me

[%step]
* breaking things in Scala for 8+ years
* breaking things for money for 10 years
* breaking things for fun for 18(?) years
* a little bit of open source - including co-authoring Chimney for 6 years now
* blog at https://kubuszok.com[Kubuszok.com]
* niche https://leanpub.com/jvm-scala-book[Things you need to know about JVM (that matter in Scala)] ebook

[NOTE.speaker]
--
Every presentation should start with some excuse, why you even are here
--

== Agenda

[%step]
* What is macro method?
* expressions and types
* quotes and quasiquotes
* compile time reflections
* I will focus on examples that I saw while maintaining my libraries
* I will NOT focus on macro annotations

[NOTE.speaker]
--
TODO
--

== What is macro method?

We can intuitively think that macro method is a code generator pretending to be some object's method.

[NOTE.speaker]
--
We'll explain what we mean by that in the next few examples. We'll show how macros differ in behavior from normal method.
--

=== Let's see an example of a very simple macro

[%step]
1. Calling the impl method is the only thing we are allowed to do.
2. ``Expr[A]`` is the AST of code that represents the value of type ``A``.
3. Why Scala 2 call it blackbox will be explained later.
4. We can already notice one difference: Scala 3 has "global" expressions while Scala 2 use path-dependent types for them.

[NOTE.speaker]
--
We're start with the simplest code that returns a constant value (``01_simple_macro``).

I can mention that expression is basically anything that computes a value.
--

=== Can the AST generation be in a different place than macro method?

[%step]
1. Impl doesn't have to be in the same definition as unquoting - it doesn't even have to be in the same package!
2. Impl has to be defined in a preceeding compilation unit to call site (macro referring to it can be in the same as call site).

[NOTE.speaker]
--
Then we're going to look at the example above but with classes (``02_macro_with_classes``).

This is the first trope that we shouldn't treat macros as methods - they don't even have to be define in the same place as what unquotes them.
--

=== Let's call some method in the macro

[NOTE.speaker]
--
Now let's call some method in the same object as the macro (``03_calling_methods``).

We are ancouraged to use full qualified name in Scala 2 as it doesn't understand context in quasiquotes.

If we used private method, compilation would fail since external code cannot access private methods (``04_calling_private``).

This is a first
--

=== Let's try printing some parameters

[%step]
[cols="1,1",%autowidth]
|===
| Scala 2
| Scala 3

| ``(c: scala.reflect.macros.blackbox.Context)``
| ``(using quotes: scala.quoted.Quotes)``

| ``c.WeakTypeTag[A]`` (or ``c.TypeTag[A]``)
| ``scala.quoted.Type[A]``

| ``c.Type``
| ``quotes.reflect.TypeRepr``

| ``c.Expr[A]``
| ``scala.quoted.Expr[A]``

| ``c.universe.Tree``
| ``quotes.reflect.Tree``

| ``c.prefix``
| no counterpart

|===

[NOTE.speaker]
--
At first let's print some parameters to see how printing works (``05_print_param``).

Then let's try to print ``this`` (``06_print_this``).

Scala 2 require the same names and positions of parametrs in macro and in called impl definition.

Scala 2 require path-dependent type for WeakTypeTag as well, Scala 3 does not require it (like with Expr).

Typed representations exists to be passed around (as params/returns/implicits), untyped can be actually worked with.

Scala 2 contains a special value for what was before macro, and Scala 3 requires us to pass it explicitly.
--

=== !

[cols="1,1",%autowidth]
|===
| Scala 2
| Scala 3

| ``c.WeakTypeTag[A](tpe: c.Type)``
| ``(tpe: TypeRepr).asType.asInstanceOf[Type[A]]``

| ``c.Expr[A](tree)``
| ``tree.asExprOf[A]``

|===

[NOTE.speaker]
--
``WeakTypeTag`` can only store proper types.

``quoted.Type`` has ``AnyKind`` so it can also store type constructor.

``asExprOf`` takes implicit ``Type``.
--

=== !

[cols="1,1",%autowidth]
|===
| Scala 2
| Scala 3

| ``show(expr)`` or ``showCode(expr)``
| ``expr.asTerm.show`` or ``expr.asTerm.show(using Printer.TreeCode)``

| no counterpart
| ``expr.asTerm.show(using Printer.TreeAnsiCode)``

| ``showRaw(expr)``
| ``expr.asTerm.show(using Printer.TreeStrucrture)``

| ``weakTypeOf[A].toString``
| ``TypeRepr.of[A].show`` or ``TypeRepr.of[A].show(using Printer.TypeReprCode)``

| no counterpart
| ``TypeRepr.of[A].show(using Printer.TypeReprAnsiCode)``

| ``showRaw(weakTypeOf[A])``
| ``TypeRepr.of[A].show(using Printer.TypeReprStructure)``

|===

[NOTE.speaker]
--
At first let's print some parameters to see how printing works (``05_print_param``).

Then let's try to print ``this`` (``06_print_this``).

Scala 2 always carries around what was "before" dot macro method name, Scala 3 requires explicit passing of this.

Scala 2 require path-dependent type for WeakTypeTag as well, Scala 3 does not require it (like with Expr).

Scala 2 require the same names and positions of parametrs in macro and in called impl definition.

Scala 2 contains a special value for what was before macro, and Scala 3 requires us to pass it explicitly.
--

=== !

TODO: error reporting (07_...)

== Analyzing types

[%step]
[cols="1,1",%autowidth]
|===
| Scala 2
| Scala 3

| ``(tpe: c.Type).typeSymbol``
| ``(repr: TypeRepr).typeSymbol``

| ``sym.isType`` / ``sym.isClass`` / ``sym.isModule`` / ``sym.isTerm``
| ``sym.isType`` / ``sym.isClassDef`` / --- / ``sym.isTerm``

| ``sym.asType``, ``sym.asClass``, ``sym.asModule``, ``sym.asTerm``
| only 1 kind of ``Symbol``

| ``sym.asClass.primaryConstructor``
| ``sym.primaryConstructor``

| ``NoSymbol``
| ``Symbol.noSymbol``

| ``(tpe: c.Type).decls``
| ``sym.declaredFields`` / ``sym.declaredMethods``

| ``(tpe: c.Type).members``
| ``sym.fieldMembers`` / ``sym.methodMembers``

|===

[NOTE.speaker]
--
Let's try to see what information we can obtain from the type (``08_analyzing_type``).

1. Scala 3 has no ``isModule`` - we need to check that something has ``Flag.Modules``
2. Scala 2 name it ``isClass`` and Scala 3 ``isClassDef``
3. When class nas no constructor it has a special ``NoSymbol`` value
4. Scala 2 has ``members`` (all definitions, inherited or declared) and ``decls`` (only definitions defined in the type) in ``Type``, Scala 3 separated fields from methods and store them in ``Symbol``

I can explain that Symbol is basically anything which can have a name or handle to be referred to.

--

=== !

case class | sealed
pattern match
  - sealed create all
  - case class create if defaults

TODO: generics
TODO: pattern matching and creating types

== Building expressions

TODO: call constructor (using implicits as params)
TODO: pattern maching

== Skeletons in a closet

TODO: generyczne typy w Scali 2 (konieczność type parameters)
TODO: companion object w Scali 2 (ten cudowny kod + defaulty)
TODO: generyki w Scali 3 (brak typeSignatureIn)
TODO: flags to tylko flagi (przykład z public)
TODO: fresh termy (przykład z val/var, function)

== TODO

[%step]
* show that code can be checked by linters/for encapsulation
* explain reporting - println vs blessed options
* analyzing the type (primary constructor, methods etc)
* Symbols
* some nice graphs illustrating relationships with Symbols (e.g. type parameters, value parameters, returned value)
* Scala 2 vs Scala 3 - parameters lists (2 in Scala 2, one in Scala 3)
* companion objects and default values (nice example with messed up Scala 2 companion, difference in naming)
* children vs knownDirectSubtypes
* generics (typeSignature, typeSignatureIn vs ...)
* Scala 2 quasiquotes for... things vs... virtually nothing (type matches and that's it)
* implicit summoning
* macro bundles vs ... nothing really
* whitebox macros vs transparent inline def (Scala 2.12 requores Tree)

== Questions?

== Thank You!
